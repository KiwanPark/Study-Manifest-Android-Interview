❓ **Q) 48. Dialog란 무엇이며, 어떻게 활용하나요?**

### 📘 개념
- **Dialog**는 사용자와 앱 간의 상호작용을 위한 작은 창입니다.  
- 일반적으로 현재 Activity 위에 표시되며, 알림·확인·데이터 입력 같은 작업을 수행합니다.  
- 종류:
  - **AlertDialog**: 확인, 취소, 옵션 선택에 적합  
  - **ProgressDialog**(deprecated) → `ProgressBar`와 `DialogFragment` 조합으로 대체  
  - **Custom Dialog**: 사용자 정의 UI 삽입 가능  

---

### 🛠️ 코드 예시

```kotlin
val builder = AlertDialog.Builder(this)❓ **Q) 48. 웹 페이지를 어떻게 렌더링하나요?**

---

### 📘 개념
- **WebView**는 앱 내부에서 웹 콘텐츠(HTML/CSS/JavaScript)를 직접 표시하고 상호작용할 수 있는 **미니 브라우저** 역할을 합니다.  
- 다양한 안드로이드 버전에서 **최신 WebView 기능을 안전하게 활용**하려면 AndroidX **WebKit** 라이브러리를 사용합니다.  

---

### 🔧 WebView 초기화하기

#### XML 레이아웃에 WebView 추가
```xml
<!-- activity_main.xml -->
<WebView
    android:id="@+id/webView"
    android:layout_width="match_parent"
    android:layout_height="match_parent" />
```

#### 코드로 생성하기
```kotlin
// 그림 123. WebView.kt
val webView = WebView(this)
setContentView(webView)
```

---

### 🌐 웹 페이지 로드하기
- 네트워크 접근이 필요한 경우 **AndroidManifest.xml**에 권한을 추가합니다.

```kotlin
// 그림 124. WebView.kt
val webView: WebView = findViewById(R.id.webView)
webView.loadUrl("https://www.example.com")
```

```xml
<!-- AndroidManifest.xml -->
<uses-permission android:name="android.permission.INTERNET" />
```

---

### ⚙️ JavaScript 활성화하기
- 웹 콘텐츠가 JS를 요구하는 경우 **WebSettings**로 활성화합니다.

```kotlin
// 그림 125. WebView.kt
val webSettings = webView.settings
webSettings.javaScriptEnabled = true
```

---

### 🧭 WebView 동작 커스텀하기

#### 페이지 내비게이션 가로채기
- 외부 브라우저로 나가지 않고 **WebView 내부에서 링크 이동을 처리**하려면 `WebViewClient`를 설정합니다.  
- **API 24 미만**과 **이상**에서 오버로드가 다릅니다.

```kotlin
// 그림 126. Navigation.kt
webView.webViewClient = object : WebViewClient() {
    // API 24 미만
    override fun shouldOverrideUrlLoading(view: WebView?, url: String?): Boolean {
        url?.let { view?.loadUrl(it) }
        return true // WebView가 URL 로딩을 처리
    }

    // API 24 이상
    override fun shouldOverrideUrlLoading(
        view: WebView?, request: WebResourceRequest?
    ): Boolean {
        request?.url?.let { view?.loadUrl(it.toString()) }
        return true // 외부 브라우저로 나가지 않도록 내부 처리
    }
}
```

---

### ⬇️ 다운로드 처리하기
- WebView 내에서 발생하는 **파일 다운로드**는 `DownloadListener`로 받아서 **DownloadManager**에 위임할 수 있습니다.

```kotlin
// 그림 127. DownloadListener.kt
webView.setDownloadListener { url, userAgent, contentDisposition, mimeType, contentLength ->
    // 여기서 파일 다운로드 처리 (예: DownloadManager 사용)
    val request = DownloadManager.Request(Uri.parse(url))
    // ... (필요한 DownloadManager 설정) ...
    val downloadManager = getSystemService(Context.DOWNLOAD_SERVICE) as DownloadManager
    downloadManager.enqueue(request)
}
```

---

### 🧪 WebView에서 JavaScript 실행하기
- `evaluateJavascript`(API 19+) 또는 `loadUrl("javascript:...")` 방식으로 **JS 주입/실행**이 가능합니다.

```kotlin
// 그림 128. JavaScript.kt
// 권장: API 19+
webView.evaluateJavascript(
    "document.body.style.backgroundColor = 'red';"
) { result ->
    Log.d("WebView", "JavaScript 실행 결과: $result")
}

// 이전 방식 (결과 콜백 X)
// webView.loadUrl("javascript:document.body.style.backgroundColor = 'blue';")
```

---

### 🔗 JavaScript ↔ 안드로이드 바인딩(개요)
- `addJavascriptInterface()`로 **Java/Kotlin 객체를 JS 컨텍스트에 노출**하여, JS에서 네이티브 기능(Toast, Dialog 등)을 호출할 수 있습니다.  
- (문서 예시: *그림 129. WebAppInterface.kt* — `@JavascriptInterface`로 메서드 노출)

---

### 🔒 보안 고려 사항
- 필요하지 않다면 **JavaScript 비활성화**를 유지하세요.  
- `setAllowFileAccess()`, `setAllowFileAccessFromFileURLs()` 사용은 신중히.  
- **XSS/URL 스푸핑 방지** 위해 입력 검증 및 URL 정제 필수.  
- `@JavascriptInterface`로 노출하는 메서드는 **표면적을 최소화**하고 검증/권한 체크를 적용하세요.

---

### 🧾 요약
- WebView는 앱 내에서 웹을 렌더링하는 기본 컴포넌트이며, `WebViewClient`로 내비게이션을 커스텀하고 필요 시 JavaScript를 활성화하여 사용자 경험을 조정할 수 있습니다.  
- 다만 **보안/성능 영향**을 항상 고려해야 합니다.

---

### ⚡ 실전 질문 (문서 원문)
**Q) 외부 링크를 클릭할 때 사용자가 앱을 벗어나는 것을 방지하기 위해  
WebView 내비게이션을 효과적으로 처리하는 방법에는 무엇이 있는지 설명해 주세요**

✅ **답변**  
1) **`WebViewClient` 지정**: `shouldOverrideUrlLoading`을 구현해 **모든 URL 로딩을 WebView 내부에서 처리**하도록 합니다.  
   - **API 24 미만**: `(view, url)` 오버로드에서 `view?.loadUrl(url)` 수행 후 `true` 반환.  
   - **API 24 이상**: `(view, request)` 오버로드에서 `request.url`을 `loadUrl()`로 처리 후 `true` 반환.  
2) **다운로드 링크 대응**: 파일 다운로드 링크는 `setDownloadListener`에서 받아 **DownloadManager**로 처리해 **외부 앱 호출을 방지**합니다.  
3) **에러/리다이렉트 대비**: 필요 시 `onPageStarted/onReceivedError` 등을 함께 구현해 **의도치 않은 외부 이동**이나 실패 케이스를 제어합니다.  
4) **보안 검증**: 이동 대상 **URL 화이트리스트/스킴 필터링**과 **HTTPS 강제**로 피싱/스푸핑을 예방합니다.


builder.setTitle("알림")
    .setMessage("이 작업을 진행하시겠습니까?")
    .setPositiveButton("확인") { dialog, _ ->
        // 확인 버튼 처리
        dialog.dismiss()
    }
    .setNegativeButton("취소") { dialog, _ ->
        dialog.dismiss()
    }
builder.create().show()
```

---

### 💡 활용 포인트
- 중요한 결정을 요청할 때 사용자로부터 입력/응답을 받을 수 있음.  
- 사용자 경험을 방해하지 않도록 **필수적일 때만 사용**해야 함.  
- `DialogFragment`를 사용하면 **화면 회전 같은 구성 변경 시에도 안전**하게 다이얼로그 상태를 유지 가능.  

---

### ⚡ 실전 질문
**Q) AlertDialog와 DialogFragment의 차이점은 무엇이며, 언제 DialogFragment를 사용하는 것이 더 적절한가요?**

✅ **답변 예시**  
- `AlertDialog`: 간단한 확인·취소 팝업에 유리, 구현이 간단.  
- `DialogFragment`: FragmentManager에 의해 관리되므로 **화면 회전, 다중창 환경**에서 자동으로 상태 보존.  
- **실무에서는 DialogFragment 권장** (UI 상태 안정성 확보).  

---

### 🧭 Pro Tips for Mastery
- 다이얼로그에 복잡한 UI를 포함해야 한다면 **별도의 Fragment 레이아웃**을 만들어 `DialogFragment`로 관리하세요.  
- **메모리 누수** 방지를 위해 Dialog 객체를 Activity context가 아닌 FragmentManager에 위임하는 것이 좋습니다.  
- 사용자 흐름을 끊지 않도록 **필수적 상황**에서만 사용하세요.
